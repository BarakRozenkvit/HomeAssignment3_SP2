#### 314638669 | Barak10101998@gmail.com
# תכנות מערכות מטלה 3 - קאטן
___
הפעלה:
---
לקימפול והרצת הדמו `make catan`

לקימפול והרצת הטסט `make catanTest`



`Graph.hpp` מימוש מחלקת הגרף
---
מחלקת הגרף היא מחלקה השומרת בתוכה מטריצת שכנויות ומורכבת מכמה פונקציות:

- `void loadGraph(vector<vector<int>> matrix)` טעינת מטריצת השכנויות לאובייקט הגרף ובדיקה אם הקלט תקין

- `vector<vector<int>>& getAdjMatrix()` החזרה של הרפרנס של המטריצת שכנויות

- `string printGraph()` נחזיר מחרוזת שהיא מטריצת השכנויות של הגרף

- `bool isDirected()` נחזיר האם הגרף מכוון או לא מכוון

- `int getEdges()` נחזיר את מספר הצלעות בגרף

- `bool getisNegativeEdges()` נחזיר האם קיימות צלעות שליליות בגרף

- `void addS()` נוסיף לגרף קודקוד נוסף עם צלעות היוצאות ממנה לכל קודקוד בגרף

### אופרטורים
אופרטורים **חשבוניים** המקבלים שני גרפים ויוצרים העתק עמוק של גרף התוצאה אחרי פעולת האופרטור:
- אופרטורים אלה יכולים ליצור צלע, להחסיר צלע ולשנות את המשקל שלה
- `Graph operator+(Graph &g)` חיבור שני גרפים
- `Graph operator-(Graph &g)` חיסור שני גרפים
- `Graph operator*(Graph &g)` כפל שני גרפים

אופרטורים  **חשבוניים** המקבלים גרף יחיד ויוצרים העתק עמוק של גרף התוצאה אחרי פעולת האופרטור:
- אופרטורים אלה לא יכולים ליצור צלע ולהחסיר צלע, יכולים רק לשנות את משקלה
- `Graph operator*(int n)` הכפלה במספר שלם
- `Graph operator++(int n)` העלאה של הגרף ב1 ושינוי הגרף, העותק המוחזר הוא לפני העלאה
- `Graph operator--(int n)` הורדה של הגרף ב1 ושינוי הגרף, העותק המוחזר הוא לפני העלאה
- `Graph operator+()` חיבור אונארי, מוחזר פלוס הגרף
- `Graph operator-()` חיסור אונארי, מוחזר מינוס הגרף


אופרטורים **חשבוניים** המקבלים שני גרפים ומשנים את הגרף התוצאה:
- אופרטורים אלה יכולים ליצור צלע ולהחסיר צלע ולשנות את משקלה
- `Graph& operator+=(Graph &g);` חיבור שני גרפים
- `Graph& operator-=(Graph &g);` חיסור שני גרפים

אופרטורים  **חשבוניים** המקבלים גרף יחיד ומשנים את הגרף התוצאה:
- אופרטורים אלה לא יכולים ליצור צלע ולהחסיר צלע, יכולים רק לשנות את משקלה
- `Graph& operator++()` העלאת הגרף ב-1
- `Graph& operator--()` הורדת הגרף ב-1
- `Graph& operator*=(int n)` הכפלה במספר שלם
- `Graph& operator/=(int n)` חילוק במספר שלם

אופרטורי **השוואה** המקבלים שני גרפים ומחזירים תוצאה בוליאנית:
- `bool operator==(Graph &g);` הגרפים שווים אם המטריצת השכנויות שלהם שווה
- `bool operator!=(Graph &g);` הגרפים שונים אם הם לא שווים
- `bool operator>=(Graph &g);` אם הגרפים גדולים או שווים
- `bool operator<=(Graph &g);` אם הגרפים קטנים או שווים
- `bool operator>(Graph &g);` אם גרף הארגומנט מוכל ממש בגרף או מספר הצלעות של גרף הארגומנט קטן או מספר הקודקודים של גרף הארגומנט קטן אז גרף הארגומנט קטן מהגרף
- `bool operator<(Graph &g);` אם הגרף הארגומנט גדול מהגרף

אופרטור **הדפסה**:
- `friend ostream& operator<<(ostream& out,Graph &g)` מדפיס את הגרף

`Algorithms.hpp` מימוש מחלקת האלגוריתמים
---

מחלקת האלגוריתמים היא מחלקה המורכבת **מפונקציות סטטיות בלבד**, למלחלקה פונקציות סטטיות **פרטיות** המממשות
אלגוריתמים ידועים על גרפים:


- `BellmanFord(Graph &g,int src)` מציאת מסלול קצר מקודקוד לשאר הקודקודים לצלעות בעלות משקל חיובי ושלילי
- `Dijkstra(Graph &g,int src)` מציאת מסלול קצר מקודקוד לשאר הקודקודים לצלעות בעלות משקל חיובי
- `DFS(Graph &g, stack<int> &orderOfVertices)` סריקת קודקודים לעומק
- `twoColoringGraph(Graph &g)` צביעת הגרף לשני צבעים
- `Transpose(Graph &g)` היפוך צלעות בגרף

למחלקה פונקציות סטטיות **ציבוריות** המשתמשות בפונקציות סטטיות הפרטיות:

`bool isConnected(Graph &g)`

פונקציה זו מומשה על פי אלגוריתם למציאת רכיבי קשירות חזקה בגרף.
בעזרת אלגוריתם לסריקת קודקודים לעומק לפי סדר קודקודים מסוים.
כתוצאה מכך נקבל סדר יורד של קודקודים לפי זמני הסיום שלהם,
נעשה היפוך צלעות
ונריץ שוב סריקת קודקודים לעומק לפי סדר הקודקוד שקיבלנו.
נבדוק אם מהתוצאה של הסריקה קיבלנו יער בעל עץ אחד, אם כן הגרף קשיר חזק.

`string shortestPath(Graph &g,int src,int dest)`

פונקציה זו מומשה בעזרת אלגוריתם למציאת מסלול קצר מקודקוד לשאר הקודקודים,
נבדוק אם לא קיימות צלעות שליליות ונריץ דייקסטרה, אם כן נריץ בלמן פורד. אם מצאנו מעגל שלילי נחזיר -1,
אם מצאנו מסלול קצר נחזיר את מסלול ואם לא, נחזיר -1

`string isContainsCycle(Graph &g)`

פונקציה זו מומשה בעזרת אלגוריתם לסריקת קודקודים לעומק. באלגוריתם זה אם קיבלנו ״צלע אחורה״ (כאשר במהלך הסריקה נתקל בקודקוד אפור) האלגוריתם ישמור את שני הקוקודים.
אם קיבלנו צלע אחורה נחזיר את המעגל ואם לא, נחזיר 0

`string isBipartite(Graph &g)`

פונקציה זו מומשה בעזרת אלגוריתם לצביעת הגרף ל2 צבעים, כלומר אם הגרף 2-צביע אפשר לחלק אותו לגרף דו צדדי.
נחזיר את החלוקה אם אפשר ואם לא, נחזיר 0

`string negativeCycle(Graph g)`

פונקציה זו מומשה בעזרת האלגוריתם בלמן פורד המוצא גם אם קיים מעגל שלילי .
אם לא קיימות צלעות שליליות נחזיר 0.
אם קיימות
נקבל העתק של הגרף (ולא רפרנס) נוסיף לו קודקוד חדש המתחבר לכל הקודקודים בכיוון חד כיווני ממנו אליו עם משקל 0.
נריץ בלמן פורד מהקודקוד החדש,
אם קיים מעגל שלילי נחזיר אותו ואם לא, נחזיר 0
